/*
 * generated by Xtext 2.15.0
 */
package uk.ac.york.simpleregexp.simplereg.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.york.simpleregexp.simplereg.services.SimpleRegGrammarAccess;
import uk.ac.york.simpleregexp.simplereg.simpleReg.MultiCharacters;
import uk.ac.york.simpleregexp.simplereg.simpleReg.RegexAlternatives;
import uk.ac.york.simpleregexp.simplereg.simpleReg.RegexGroup;
import uk.ac.york.simpleregexp.simplereg.simpleReg.SimpleRegPackage;
import uk.ac.york.simpleregexp.simplereg.simpleReg.SingleChars;
import uk.ac.york.simpleregexp.simplereg.simpleReg.Wildcard;

@SuppressWarnings("all")
public class SimpleRegSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SimpleRegGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SimpleRegPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SimpleRegPackage.MULTI_CHARACTERS:
				if (rule == grammarAccess.getMultiCharactersRule()) {
					sequence_MultiCharacters(context, (MultiCharacters) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRegexAlternativesRule()
						|| action == grammarAccess.getRegexAlternativesAccess().getRegexAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getRegexGroupRule()
						|| action == grammarAccess.getRegexGroupAccess().getRegexGroupElementsAction_1_0()
						|| rule == grammarAccess.getRegexTokenRule()
						|| rule == grammarAccess.getRegexTokenElementRule()
						|| rule == grammarAccess.getParenthesizedRegexElementRule()) {
					sequence_MultiCharacters_RegexToken(context, (MultiCharacters) semanticObject); 
					return; 
				}
				else break;
			case SimpleRegPackage.REGEX_ALTERNATIVES:
				sequence_RegexAlternatives_RegexToken(context, (RegexAlternatives) semanticObject); 
				return; 
			case SimpleRegPackage.REGEX_GROUP:
				sequence_RegexGroup_RegexToken(context, (RegexGroup) semanticObject); 
				return; 
			case SimpleRegPackage.SINGLE_CHARS:
				if (rule == grammarAccess.getRegexAlternativesRule()
						|| action == grammarAccess.getRegexAlternativesAccess().getRegexAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getRegexGroupRule()
						|| action == grammarAccess.getRegexGroupAccess().getRegexGroupElementsAction_1_0()
						|| rule == grammarAccess.getRegexTokenRule()
						|| rule == grammarAccess.getRegexTokenElementRule()
						|| rule == grammarAccess.getParenthesizedRegexElementRule()) {
					sequence_RegexToken_SingleChars(context, (SingleChars) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleCharsRule()) {
					sequence_SingleChars(context, (SingleChars) semanticObject); 
					return; 
				}
				else break;
			case SimpleRegPackage.WILDCARD:
				if (rule == grammarAccess.getRegexAlternativesRule()
						|| action == grammarAccess.getRegexAlternativesAccess().getRegexAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getRegexGroupRule()
						|| action == grammarAccess.getRegexGroupAccess().getRegexGroupElementsAction_1_0()
						|| rule == grammarAccess.getRegexTokenRule()
						|| rule == grammarAccess.getRegexTokenElementRule()
						|| rule == grammarAccess.getParenthesizedRegexElementRule()) {
					sequence_RegexToken_Wildcard(context, (Wildcard) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWildcardRule()) {
					sequence_Wildcard(context, (Wildcard) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     MultiCharacters returns MultiCharacters
	 *
	 * Constraint:
	 *     value=MULTICHARTERMINAL
	 */
	protected void sequence_MultiCharacters(ISerializationContext context, MultiCharacters semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleRegPackage.Literals.MULTI_CHARACTERS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleRegPackage.Literals.MULTI_CHARACTERS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiCharactersAccess().getValueMULTICHARTERMINALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegexAlternatives returns MultiCharacters
	 *     RegexAlternatives.RegexAlternatives_1_0 returns MultiCharacters
	 *     RegexGroup returns MultiCharacters
	 *     RegexGroup.RegexGroup_1_0 returns MultiCharacters
	 *     RegexToken returns MultiCharacters
	 *     RegexTokenElement returns MultiCharacters
	 *     ParenthesizedRegexElement returns MultiCharacters
	 *
	 * Constraint:
	 *     (<unknown> value=MULTICHARTERMINAL)
	 */
	protected void sequence_MultiCharacters_RegexToken(ISerializationContext context, MultiCharacters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegexAlternatives returns RegexAlternatives
	 *     RegexAlternatives.RegexAlternatives_1_0 returns RegexAlternatives
	 *     RegexGroup returns RegexAlternatives
	 *     RegexGroup.RegexGroup_1_0 returns RegexAlternatives
	 *     RegexToken returns RegexAlternatives
	 *     RegexTokenElement returns RegexAlternatives
	 *     ParenthesizedRegexElement returns RegexAlternatives
	 *
	 * Constraint:
	 *     (<unknown> elements+=RegexAlternatives_RegexAlternatives_1_0 elements+=RegexGroup+)
	 */
	protected void sequence_RegexAlternatives_RegexToken(ISerializationContext context, RegexAlternatives semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegexAlternatives returns RegexGroup
	 *     RegexAlternatives.RegexAlternatives_1_0 returns RegexGroup
	 *     RegexGroup returns RegexGroup
	 *     RegexGroup.RegexGroup_1_0 returns RegexGroup
	 *     RegexToken returns RegexGroup
	 *     RegexTokenElement returns RegexGroup
	 *     ParenthesizedRegexElement returns RegexGroup
	 *
	 * Constraint:
	 *     (<unknown> elements+=RegexGroup_RegexGroup_1_0 elements+=RegexToken+)
	 */
	protected void sequence_RegexGroup_RegexToken(ISerializationContext context, RegexGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegexAlternatives returns SingleChars
	 *     RegexAlternatives.RegexAlternatives_1_0 returns SingleChars
	 *     RegexGroup returns SingleChars
	 *     RegexGroup.RegexGroup_1_0 returns SingleChars
	 *     RegexToken returns SingleChars
	 *     RegexTokenElement returns SingleChars
	 *     ParenthesizedRegexElement returns SingleChars
	 *
	 * Constraint:
	 *     (<unknown> value=TSINGLECHARSDT)
	 */
	protected void sequence_RegexToken_SingleChars(ISerializationContext context, SingleChars semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegexAlternatives returns Wildcard
	 *     RegexAlternatives.RegexAlternatives_1_0 returns Wildcard
	 *     RegexGroup returns Wildcard
	 *     RegexGroup.RegexGroup_1_0 returns Wildcard
	 *     RegexToken returns Wildcard
	 *     RegexTokenElement returns Wildcard
	 *     ParenthesizedRegexElement returns Wildcard
	 *
	 * Constraint:
	 *     <unknown>
	 */
	protected void sequence_RegexToken_Wildcard(ISerializationContext context, Wildcard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleChars returns SingleChars
	 *
	 * Constraint:
	 *     value=TSINGLECHARSDT
	 */
	protected void sequence_SingleChars(ISerializationContext context, SingleChars semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleRegPackage.Literals.SINGLE_CHARS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleRegPackage.Literals.SINGLE_CHARS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleCharsAccess().getValueTSINGLECHARSDTParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Wildcard returns Wildcard
	 *
	 * Constraint:
	 *     {Wildcard}
	 */
	protected void sequence_Wildcard(ISerializationContext context, Wildcard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
