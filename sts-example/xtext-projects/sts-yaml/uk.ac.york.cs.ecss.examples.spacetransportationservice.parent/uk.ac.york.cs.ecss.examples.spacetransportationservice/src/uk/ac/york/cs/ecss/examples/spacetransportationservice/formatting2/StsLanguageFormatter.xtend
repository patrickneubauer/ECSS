/*
 * generated by Xtext 2.15.0
 */
package uk.ac.york.cs.ecss.examples.spacetransportationservice.formatting2

import com.google.inject.Inject
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Stack
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.AbstractRule
import org.eclipse.xtext.GrammarUtil
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import uk.ac.york.cs.ecss.examples.spacetransportationservice.services.StsLanguageGrammarAccess

class StsLanguageFormatter extends AbstractFormatter2 {
	
	@Inject extension StsLanguageGrammarAccess

	/*
	def void configureFormatting(FormattingConfig c) {
		//val beginRule = grammar.rules.stream.filter([x|"BEGIN".equals(x.name)]).findAny.get;
		//val endRule = grammar.rules.stream.filter([x|"END".equals(x.name)]).findAny.get;
		
	
	}
	 */
	/*
	def List<Pair<RuleCall,RuleCall>> findRulePairs(AbstractRule beginRule, AbstractRule endRule) {
		//Only if in same container
		val allRules = new HashMap();
		val ret = new ArrayList();
		for (RuleCall ar: findRuleCalls(beginRule,endRule)) {
			val cobj = ar.eContainer;
			allRules.computeIfAbsent(cobj, [x | new ArrayList()]).add(ar);
		}
		allRules.forEach[k, list|
			val stack = new Stack();
			for (RuleCall rc: list) {
				if (rc.rule == beginRule) {
					stack.push(rc);
				} else { //endRule
					if (stack.isEmpty) {
						System.err.println("Empty stack! Incomptabile!");
					} else {
						val beginCall = stack.pop();
						val endCall = rc;
						ret.add(new Pair(beginCall, endCall));
					}
				}
			}
		];
		
		return ret;
	} */
	
	def List<Pair<ISemanticRegion,ISemanticRegion>>  getRCPairs(EObject eobj, AbstractRule beginRule, AbstractRule endRule) {
		val allSemanticRegions = new ArrayList();
		val semanticRegionType = new HashMap();
		for (ISemanticRegion isr: eobj.regionFor.ruleCallsTo(beginRule)) {
			semanticRegionType.put(isr, true);
		}
		for (ISemanticRegion isr: eobj.regionFor.ruleCallsTo(endRule)) {
			semanticRegionType.put(isr, false);
		}
		for (ISemanticRegion isr: eobj.regionFor.ruleCallsTo(beginRule, endRule)) {
			//Can we find out to which one it belongs? Then this could be faster ...
			allSemanticRegions.add(isr);			
		}
		
		val ret = new ArrayList();
		val stack = new Stack();
		for (ISemanticRegion isr: allSemanticRegions) {
			val type = semanticRegionType.get(isr);
			if (type) {
				stack.push(isr);
			} else {
				if (stack.isEmpty) {
					System.err.println("Empty stack! Incomptabile!");
				} else {
					val beginIsr = stack.pop();
					val endIsr = isr;
					ret.add(new Pair(beginIsr, endIsr));
				}
			}
		}
		return ret;
		
	}
	
	override dispatch void format(EObject obj, IFormattableDocument document) {
			
		
		//TODO: This only works for fixed indentations ...
		for (Pair<ISemanticRegion,ISemanticRegion> pair: getRCPairs(obj, BEGINRule, ENDRule)) {
			document.interior(pair.key, pair.value, [indent]);
			document.surround(pair.key, [noSpace]);
		}
		
		obj.eContents.forEach[x | format(x, document)];
		
		regionFor(obj).
			keywords(GrammarUtil.getAllKeywords(grammar).toArray(#[] as Keyword[])).forEach[x |
				document.surround(x,[noAutowrap]);
			];
			
		document.surround(obj, [noAutowrap]);
			
	}
	
	
	/*def dispatch void format(Model model, extension IFormattableDocument document) {
		model.prepend[setNewLines(0, 0, 1); noSpace]
		for (Declaration declaration : model.getDeclarations()) {
			declaration.format.append[setNewLines(1, 1, 2)]
		}
	}

	def dispatch void format(Device device, extension IFormattableDocument document) {
		device.regionFor.feature(DEVICE__NAME).surround[oneSpace]
		device.regionFor.keyword("be").surround[oneSpace]
		for (State state : device.getStates()) {
			state.format.immediatelyPreceding.keyword(",").prepend[noSpace].append[oneSpace]
		}
	}

	def dispatch void format(Rule rule, extension IFormattableDocument document) {
		rule.regionFor.feature(RULE__DESCRIPTION).surround[oneSpace]
		rule.regionFor.feature(RULE__DEVICE_STATE).surround[oneSpace]
		rule.thenPart.format.prepend[newLine]
	}

	override dispatch void format(XBlockExpression expr, extension IFormattableDocument document) {
		expr.surround[indent]
		for (child : expr.expressions) {
			val sem = child.immediatelyFollowing.keyword(";")
			if (sem !== null) {
				sem.prepend[noSpace]
				if (child != expr.expressions.last)
					sem.append[newLine]
			} else if (child != expr.expressions.last)
				child.append[newLine]
			child.format
		}
	}

	override dispatch void format(XSwitchExpression expr, extension IFormattableDocument document) {
		set(expr.^switch.previousHiddenRegion, expr.nextHiddenRegion)[indent]
		expr.regionFor.keyword("switch").append[oneSpace]
		expr.^switch.append[newLine].format
		for (c : expr.cases) {
			if (c.typeGuard !== null && c.^case !== null) {
				c.typeGuard.append[oneSpace]
				c.^case.append[noSpace]
			} else if (c.typeGuard !== null) {
				c.typeGuard.append[noSpace]
			} else if (c.^case !== null) {
				c.^case.prepend[oneSpace].append[noSpace]
			}
			c.regionFor.feature(XCASE_PART__FALL_THROUGH).prepend[noSpace].append[newLine]
			c.^case.format
			if (c == expr.cases.last && expr.^default === null)
				c.then.formatBody(true, document)
			else
				c.then.formatBodyParagraph(document)
		}
		if (expr.^default !== null) {
			expr.regionFor.keyword("default").append[noSpace]
			expr.^default.formatBody(true, document)
		}
	}

	override protected void formatBody(XExpression expr, boolean forceMultiline, extension IFormattableDocument doc) {
		if (expr === null)
			return;
		if (expr instanceof XBlockExpression) {
			expr.prepend[newLine]
		} else if (forceMultiline || expr.previousHiddenRegion.isMultiline) {
			expr.prepend[newLine].surround[indent]
		} else {
			expr.prepend[oneSpace]
		}
		expr.format
	}

	override protected void formatBodyInline(XExpression expr, boolean forceMultiline,
		extension IFormattableDocument doc) {
		if (expr === null)
			return;
		if (expr instanceof XBlockExpression) {
			expr.surround[newLine]
		} else if (forceMultiline || expr.previousHiddenRegion.isMultiline) {
			expr.prepend[newLine].surround[indent].append[newLine]
		} else {
			expr.surround[oneSpace]
		}
		expr.format
	}

	override protected void formatBodyParagraph(XExpression expr, extension IFormattableDocument doc) {
		if (expr === null)
			return;
		if (expr instanceof XBlockExpression) {
			expr.surround[newLine]
		} else {
			expr.surround[oneSpace]
		}
		expr.format
	}*/
}