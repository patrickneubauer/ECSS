// automatically generated by Xtext
grammar deflang.com.github.jknack.antlr4ide.Antlr4 with org.eclipse.xtext.common.Terminals

import "http://www.com.srclang/github/jknack/antlr4ide/Antlr4" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Grammar returns Grammar:
	{Grammar}
	'Grammar'
	name=EString
	'{'
		('type' type=GrammarType)?
		('prequels' '{' prequels+=PrequelConstruct ( "," prequels+=PrequelConstruct)* '}' )?
		('rules' '{' rules+=Rule ( "," rules+=Rule)* '}' )?
		('modes' '{' modes+=Mode ( "," modes+=Mode)* '}' )?
	'}';

PrequelConstruct returns PrequelConstruct:
	PrequelConstruct_Impl | Options | Imports | Tokens_Impl | V4Tokens | EmptyTokens | V3Tokens | GrammarAction;

Rule returns Rule:
	Rule_Impl | ParserRule | LexerRule;



Option returns Option:
	Option_Impl | TokenVocab;




OptionValue returns OptionValue:
	OptionValue_Impl | QualifiedOption | StringOption | ActionOption | IntOption;





RulePrequel returns RulePrequel:
	RulePrequel_Impl | Options | RuleAction;





















LexerCommandArg returns LexerCommandArg:
	LexerCommandArg_Impl | V4Token | V3Token | Mode | LexerRule;

enum GrammarType returns GrammarType:
				DEFAULT = 'DEFAULT' | LEXER = 'LEXER' | PARSER = 'PARSER' | TREE = 'TREE';

EString returns ecore::EString:
	STRING | ID;

PrequelConstruct_Impl returns PrequelConstruct:
	{PrequelConstruct}
	'PrequelConstruct'
	;

Rule_Impl returns Rule:
	{Rule}
	'Rule'
	name=EString
	'{'
		('semicolonSymbol' semicolonSymbol=EString)?
	'}';

Mode returns Mode:
	{Mode}
	'Mode'
	'{'
		('id' id=EString)?
		('rules' '{' rules+=LexerRule ( "," rules+=LexerRule)* '}' )?
	'}';

Options returns Options:
	{Options}
	'Options'
	'{'
		('keyword' keyword=EString)?
		('options' '{' options+=Option ( "," options+=Option)* '}' )?
	'}';

Imports returns Imports:
	{Imports}
	'Imports'
	'{'
		('keyword' keyword=EString)?
		('imports' '{' imports+=Import ( "," imports+=Import)* '}' )?
	'}';

Tokens_Impl returns Tokens:
	{Tokens}
	'Tokens'
	'{'
		('keyword' keyword=EString)?
	'}';

V4Tokens returns V4Tokens:
	{V4Tokens}
	'V4Tokens'
	'{'
		('keyword' keyword=EString)?
		('tokens' '{' tokens+=V4Token ( "," tokens+=V4Token)* '}' )?
	'}';

EmptyTokens returns EmptyTokens:
	{EmptyTokens}
	'EmptyTokens'
	'{'
		('keyword' keyword=EString)?
	'}';

V3Tokens returns V3Tokens:
	{V3Tokens}
	'V3Tokens'
	'{'
		('keyword' keyword=EString)?
		('tokens' '{' tokens+=V3Token ( "," tokens+=V3Token)* '}' )?
	'}';

GrammarAction returns GrammarAction:
	{GrammarAction}
	'GrammarAction'
	name=EString
	'{'
		('atSymbol' atSymbol=EString)?
		('scope' scope=EString)?
		('colonSymbol' colonSymbol=EString)?
		('action' action=EString)?
	'}';

Option_Impl returns Option:
	{Option}
	'Option'
	name=EString
	'{'
		('value' value=OptionValue)?
	'}';

OptionValue_Impl returns OptionValue:
	{OptionValue}
	'OptionValue'
	;

TokenVocab returns TokenVocab:
	{TokenVocab}
	'TokenVocab'
	name=EString
	'{'
		('importURI' importURI=[Grammar|EString])?
		('value' value=OptionValue)?
	'}';

QualifiedOption returns QualifiedOption:
	{QualifiedOption}
	'QualifiedOption'
	'{'
		('value' value=QualifiedId)?
	'}';

StringOption returns StringOption:
	{StringOption}
	'StringOption'
	'{'
		('value' value=EString)?
	'}';

ActionOption returns ActionOption:
	{ActionOption}
	'ActionOption'
	'{'
		('value' value=EString)?
	'}';

IntOption returns IntOption:
	{IntOption}
	'IntOption'
	'{'
		('value' value=EInt)?
	'}';

QualifiedId returns QualifiedId:
	{QualifiedId}
	'QualifiedId'
	'{'
		('name' '{' name+=EString ( "," name+=EString)* '}' )?
	'}';

EInt returns ecore::EInt:
	'-'? INT;

Import returns Import:
	{Import}
	'Import'
	'{'
		('alias' alias=EString)?
		('importURI' importURI=[Grammar|EString])?
	'}';

V4Token returns V4Token:
	{V4Token}
	'V4Token'
	name=EString;

V3Token returns V3Token:
	{V3Token}
	'V3Token'
	'{'
		('id' id=EString)?
		('value' value=EString)?
	'}';

ParserRule returns ParserRule:
	{ParserRule}
	'ParserRule'
	name=EString
	'{'
		('semicolonSymbol' semicolonSymbol=EString)?
		('args' args=EString)?
		('return' return=Return)?
		('throws' throws=Exceptions)?
		('locals' locals=LocalVars)?
		('prequels' '{' prequels+=RulePrequel ( "," prequels+=RulePrequel)* '}' )?
		('body' body=RuleBlock)?
		('caught' caught=ExceptionGroup)?
	'}';

LexerRule returns LexerRule:
	{LexerRule}
	(^fragment?='fragment')?
	'LexerRule'
	name=EString
	'{'
		('semicolonSymbol' semicolonSymbol=EString)?
		('body' body=LexerRuleBlock)?
	'}';

Return returns Return:
	{Return}
	'Return'
	'{'
		('body' body=EString)?
	'}';

Exceptions returns Exceptions:
	{Exceptions}
	'Exceptions'
	'{'
		('exceptions' '{' exceptions+=QualifiedId ( "," exceptions+=QualifiedId)* '}' )?
	'}';

LocalVars returns LocalVars:
	{LocalVars}
	'LocalVars'
	'{'
		('body' body=EString)?
	'}';

RulePrequel_Impl returns RulePrequel:
	{RulePrequel}
	'RulePrequel'
	;

RuleBlock returns RuleBlock:
	{RuleBlock}
	'RuleBlock'
	'{'
		('body' body=RuleAltList)?
	'}';

ExceptionGroup returns ExceptionGroup:
	{ExceptionGroup}
	'ExceptionGroup'
	'{'
		('handlers' '{' handlers+=ExceptionHandler ( "," handlers+=ExceptionHandler)* '}' )?
		('finally' finally=FinallyClause)?
	'}';

RuleAction returns RuleAction:
	{RuleAction}
	'RuleAction'
	name=EString
	'{'
		('atSymbol' atSymbol=EString)?
		('body' body=EString)?
	'}';

RuleAltList returns RuleAltList:
	{RuleAltList}
	'RuleAltList'
	'{'
		('alternatives' '{' alternatives+=LabeledAlt ( "," alternatives+=LabeledAlt)* '}' )?
	'}';

LabeledAlt returns LabeledAlt:
	{LabeledAlt}
	'LabeledAlt'
	'{'
		('poundSymbol' poundSymbol=EString)?
		('label' label=EString)?
		('body' body=Alternative)?
	'}';

Alternative returns Alternative:
	{Alternative}
	'Alternative'
	'{'
		('options' options=ElementOptions)?
		('elements' '{' elements+=Element ( "," elements+=Element)* '}' )?
	'}';

ElementOptions returns ElementOptions:
	{ElementOptions}
	'ElementOptions'
	'{'
		('begin' begin=EString)?
		('end' end=EString)?
		('options' '{' options+=ElementOption ( "," options+=ElementOption)* '}' )?
	'}';

Element returns Element:
	{Element}
	'Element'
	'{'
		('body' body=EObject)?
		('operator' operator=EbnfSuffix)?
	'}';

ElementOption returns ElementOption:
	{ElementOption}
	'ElementOption'
	'{'
		('id' id=EString)?
		('assign' assign=EString)?
		('qualifiedId' qualifiedId=QualifiedId)?
		('value' value=OptionValue)?
	'}';

EObject returns ecore::EObject:
	{ecore::EObject}
	'EObject'
	;

EbnfSuffix returns EbnfSuffix:
	{EbnfSuffix}
	'EbnfSuffix'
	'{'
		('operator' operator=EString)?
		('nongreedy' nongreedy=EString)?
	'}';

ExceptionHandler returns ExceptionHandler:
	{ExceptionHandler}
	'ExceptionHandler'
	'{'
		('exception' exception=EString)?
		('body' body=EString)?
	'}';

FinallyClause returns FinallyClause:
	{FinallyClause}
	'FinallyClause'
	'{'
		('body' body=EString)?
	'}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

LexerRuleBlock returns LexerRuleBlock:
	{LexerRuleBlock}
	'LexerRuleBlock'
	'{'
		('body' body=LexerAltList)?
	'}';

LexerAltList returns LexerAltList:
	{LexerAltList}
	'LexerAltList'
	'{'
		('alternatives' '{' alternatives+=LexerAlt ( "," alternatives+=LexerAlt)* '}' )?
	'}';

LexerAlt returns LexerAlt:
	{LexerAlt}
	'LexerAlt'
	'{'
		('body' body=LexerElements)?
		('commands' commands=LexerCommands)?
	'}';

LexerElements returns LexerElements:
	{LexerElements}
	'LexerElements'
	'{'
		('elements' '{' elements+=LexerElement ( "," elements+=LexerElement)* '}' )?
	'}';

LexerCommands returns LexerCommands:
	{LexerCommands}
	'LexerCommands'
	'{'
		('keyword' keyword=EString)?
		('commands' '{' commands+=LexerCommand ( "," commands+=LexerCommand)* '}' )?
	'}';

LexerElement returns LexerElement:
	{LexerElement}
	'LexerElement'
	'{'
		('body' body=EObject)?
		('operator' operator=EbnfSuffix)?
	'}';

LexerCommand returns LexerCommand:
	{LexerCommand}
	'LexerCommand'
	name=EString
	'{'
		('args' args=LexerCommandExpr)?
	'}';

LexerCommandExpr returns LexerCommandExpr:
	{LexerCommandExpr}
	'LexerCommandExpr'
	'{'
		('value' value=EInt)?
		('ref' ref=[LexerCommandArg|EString])?
	'}';

LexerCommandArg_Impl returns LexerCommandArg:
	{LexerCommandArg}
	'LexerCommandArg'
	;
