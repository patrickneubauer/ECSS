// automatically generated by Xtext
grammar trglang.com.puppetlabs.geppetto.pp.dsl1.PP

import "http://www.puppetlabs.com/geppetto/1.0.0/PP1" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

TextExpression:
	ExpressionTE | VerbatimTE | VariableTE;

VerbatimTE:
	{VerbatimTE} "VerbatimTE" "{" text=ESTRING? "}";

ExpressionTE:
	{ExpressionTE} "ExpressionTE" "{" expression=Expression? "}";

VariableTE:
	{VariableTE} "VariableTE" "{" varName=ESTRING? "}";

terminal ESTRING:
	"\"" ("\\" . | !("\\" | "\""))* "\"" | "\'" ("\\" . | !("\\" | "\'"))* "\'";

Expression:
	UnaryExpression | StringExpression | InterpolatedVariable | ExprList | CaseExpression | SeparatorExpression |
	IfExpression | UnlessExpression | ResourceExpression | CollectExpression | ExpressionBlock | Definition |
	VariableExpression | LiteralExpression | ParenthesisedExpression | BinaryExpression | ParameterizedExpression |
	ImportExpression | NodeDefinition;

ParameterizedExpression:
	AtExpression | WithLambdaExpression | SelectorExpression;

CaseExpression:
	{CaseExpression} "CaseExpression" "{" switchExpr=Expression? (cases+=Case ("," cases+=Case)*)? "}";

NodeDefinition:
	{NodeDefinition} "NodeDefinition" "{" (hostNames+=Expression ("," hostNames+=Expression)*)? parentName=Expression?
	(statements+=Expression ("," statements+=Expression)*)? "}";

SeparatorExpression:
	{SeparatorExpression} "SeparatorExpression" "{" "}";

CollectExpression:
	{CollectExpression} "CollectExpression" "{" classReference=Expression? query=ICollectQuery?
	attributes=AttributeOperations? "}";

BinaryExpression:
	NamedAccessExpression | AppendExpression | AssignmentExpression | OrExpression | BinaryOpExpression | AndExpression |
	SelectorEntry;

IfExpression:
	ElseIfExpression;

ResourceExpression:
	{ResourceExpression} "ResourceExpression" "{" resourceExpr=Expression? (resourceData+=ResourceBody (","
	resourceData+=ResourceBody)*)? "}";

LiteralExpression:
	LiteralNameOrReference | LiteralRegex | LiteralList | LiteralClass | VirtualNameOrReference | LiteralUndef |
	LiteralHash | LiteralBoolean | LiteralDefault | LiteralName;

Definition:
	HostClassDefinition;

UnlessExpression:
	{UnlessExpression} "UnlessExpression" "{" condExpr=Expression? (thenStatements+=Expression (","
	thenStatements+=Expression)*)? elseStatement=Expression? "}";

StringExpression:
	DoubleQuotedString | SingleQuotedString | UnquotedString;

ParenthesisedExpression:
	{ParenthesisedExpression} "ParenthesisedExpression" "{" expr=Expression? "}";

InterpolatedVariable:
	{InterpolatedVariable} "InterpolatedVariable" "{" varName=ESTRING? "}";

ImportExpression:
	{ImportExpression} "ImportExpression" "{" (values+=IQuotedString ("," values+=IQuotedString)*)? "}";

VariableExpression:
	{VariableExpression} "VariableExpression" "{" varName=ESTRING? "}";

ExprList:
	{ExprList} "ExprList" "{" (expressions+=Expression ("," expressions+=Expression)*)? "}";

ExpressionBlock:
	Lambda | PuppetManifest | ElseExpression;

UnaryExpression:
	UnaryMinusExpression | UnaryNotExpression | VirtualCollectQuery | ExportedCollectQuery;

VirtualCollectQuery:
	{VirtualCollectQuery} "VirtualCollectQuery" "{" expr=Expression? "}";

UnaryMinusExpression:
	{UnaryMinusExpression} "UnaryMinusExpression" "{" expr=Expression? "}";

UnaryNotExpression:
	{UnaryNotExpression} "UnaryNotExpression" "{" expr=Expression? "}";

ExportedCollectQuery:
	{ExportedCollectQuery} "ExportedCollectQuery" "{" expr=Expression? "}";

Lambda:
	RubyLambda | JavaLambda;

ElseExpression:
	{ElseExpression} "ElseExpression" "{" (statements+=Expression ("," statements+=Expression)*)? "}";

PuppetManifest:
	{PuppetManifest} "PuppetManifest" "{" (statements+=Expression ("," statements+=Expression)*)? "}";

IQuotedString:
	DoubleQuotedString | SingleQuotedString;

UnquotedString:
	{UnquotedString} "UnquotedString" "{" expression=Expression? "}";

DoubleQuotedString:
	{DoubleQuotedString} "DoubleQuotedString" "{" (stringPart+=TextExpression ("," stringPart+=TextExpression)*)? "}";

SingleQuotedString:
	{SingleQuotedString} "SingleQuotedString" "{" text=ESTRING? "}";

HostClassDefinition:
	{HostClassDefinition} "HostClassDefinition" "{" className=ESTRING? arguments=DefinitionArgumentList?
	(statements+=Expression ("," statements+=Expression)*)? parent=LiteralExpression? "}";

LiteralDefault:
	{LiteralDefault} "LiteralDefault" "{" "}";

LiteralBoolean:
	{LiteralBoolean} "LiteralBoolean" "{" value?=EBOOLEAN? "}";

LiteralClass:
	{LiteralClass} "LiteralClass" "{" "}";

LiteralName:
	{LiteralName} "LiteralName" "{" value=ESTRING? "}";

LiteralUndef:
	{LiteralUndef} "LiteralUndef" "{" "}";

LiteralHash:
	{LiteralHash} "LiteralHash" "{" (elements+=HashEntry ("," elements+=HashEntry)*)? "}";

LiteralNameOrReference:
	{LiteralNameOrReference} "LiteralNameOrReference" "{" value=ESTRING? "}";

LiteralRegex:
	{LiteralRegex} "LiteralRegex" "{" value=ESTRING? "}";

LiteralList:
	{LiteralList} "LiteralList" "{" (elements+=Expression ("," elements+=Expression)*)? "}";

VirtualNameOrReference:
	{VirtualNameOrReference} "VirtualNameOrReference" "{" value=ESTRING? exported?=EBOOLEAN? "}";

ResourceBody:
	{ResourceBody} "ResourceBody" "{" attributes=AttributeOperations? nameExpr=Expression? "}";

ElseIfExpression:
	{ElseIfExpression} "ElseIfExpression" "{" condExpr=Expression? (thenStatements+=Expression (","
	thenStatements+=Expression)*)? elseStatement=Expression? "}";

SelectorEntry:
	{SelectorEntry} "SelectorEntry" "{" leftExpr=Expression? rightExpr=Expression? "}";

AssignmentExpression:
	{AssignmentExpression} "AssignmentExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

AndExpression:
	{AndExpression} "AndExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

NamedAccessExpression:
	{NamedAccessExpression} "NamedAccessExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

AppendExpression:
	{AppendExpression} "AppendExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

OrExpression:
	{OrExpression} "OrExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

BinaryOpExpression:
	MultiplicativeExpression | ShiftExpression | RelationshipExpression | RelationalExpression | AdditiveExpression |
	InExpression | EqualityExpression | MatchingExpression;

ICollectQuery:
	VirtualCollectQuery | ExportedCollectQuery;

AttributeOperations:
	{AttributeOperations} "AttributeOperations" "{" (attributes+=AttributeOperation (","
	attributes+=AttributeOperation)*)? "}";

Case:
	{Case} "Case" "{" (statements+=Expression ("," statements+=Expression)*)? (values+=Expression (","
	values+=Expression)*)? "}";

WithLambdaExpression:
	FunctionCall | MethodCall;

SelectorExpression:
	{SelectorExpression} "SelectorExpression" "{" leftExpr=Expression? (parameters+=Expression (","
	parameters+=Expression)*)? "}";

AtExpression:
	{AtExpression} "AtExpression" "{" leftExpr=Expression? (parameters+=Expression ("," parameters+=Expression)*)? "}";

JavaLambda:
	{JavaLambda} "JavaLambda" "{" (statements+=Expression ("," statements+=Expression)*)?
	arguments=DefinitionArgumentList? farrow?=EBOOLEAN? "}";

RubyLambda:
	{RubyLambda} "RubyLambda" "{" (statements+=Expression ("," statements+=Expression)*)?
	arguments=DefinitionArgumentList? "}";

DefinitionArgumentList:
	{DefinitionArgumentList} "DefinitionArgumentList" "{" (arguments+=DefinitionArgument (","
	arguments+=DefinitionArgument)*)? "}";

terminal EBOOLEAN returns ecore::EBoolean:
	"true" | "false";

HashEntry:
	{HashEntry} "HashEntry" "{" key=Expression? value=Expression? "}";

AttributeOperation:
	{AttributeOperation} "AttributeOperation" "{" value=Expression? key=ESTRING? op=ESTRING? "}";

MultiplicativeExpression:
	{MultiplicativeExpression} "MultiplicativeExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING?
	"}";

RelationshipExpression:
	{RelationshipExpression} "RelationshipExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

InExpression:
	{InExpression} "InExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

ShiftExpression:
	{ShiftExpression} "ShiftExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

RelationalExpression:
	{RelationalExpression} "RelationalExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

MatchingExpression:
	{MatchingExpression} "MatchingExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

AdditiveExpression:
	{AdditiveExpression} "AdditiveExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

EqualityExpression:
	{EqualityExpression} "EqualityExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

MethodCall:
	{MethodCall} "MethodCall" "{" leftExpr=Expression? (parameters+=Expression ("," parameters+=Expression)*)?
	lambda=Lambda? parenthesized?=EBOOLEAN? methodExpr=Expression "}";

FunctionCall:
	{FunctionCall} "FunctionCall" "{" leftExpr=Expression? (parameters+=Expression ("," parameters+=Expression)*)?
	lambda=Lambda? "}";

DefinitionArgument:
	{DefinitionArgument} "DefinitionArgument" "{" argName=ESTRING? value=Expression? op=ESTRING? "}";

IDDT:
	EBOOLEAN | ID;

terminal ID:
	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;