// automatically generated by Xtext
grammar trglang.com.puppetlabs.geppetto.pp.dsl2.PP

import "http://www.puppetlabs.com/geppetto/1.0.0/PP2" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

TextExpression:
	VariableTE | VerbatimTE | ExpressionTE;

ExpressionTE:
	{ExpressionTE} "ExpressionTE" "{" expression=Expression? "}";

VerbatimTE:
	{VerbatimTE} "VerbatimTE" "{" text=ESTRING? "}";

VariableTE:
	{VariableTE} "VariableTE" "{" varName=ESTRING? "}";

terminal ESTRING:
	"\"" ("\\" . | !("\\" | "\""))* "\"" | "\'" ("\\" . | !("\\" | "\'"))* "\'";

Expression:
	VariableExpression | SeparatorExpression | ParameterizedExpression | BinaryExpression | LiteralExpression |
	ExpressionBlock | ExprList | ImportExpression | InterpolatedVariable | CaseExpression | StringExpression |
	ParenthesisedExpression | ResourceExpression | UnaryExpression | CollectExpression;

InterpolatedVariable:
	{InterpolatedVariable} "InterpolatedVariable" "{" varName=ESTRING? "}";

CollectExpression:
	{CollectExpression} "CollectExpression" "{" classReference=Expression? query=ICollectQuery?
	attributes=AttributeOperations? "}";

ParenthesisedExpression:
	{ParenthesisedExpression} "ParenthesisedExpression" "{" expr=Expression? "}";

ExprList:
	{ExprList} "ExprList" "{" (expressions+=Expression ("," expressions+=Expression)*)? "}";

CaseExpression:
	{CaseExpression} "CaseExpression" "{" switchExpr=Expression? (cases+=Case ("," cases+=Case)*)? "}";

ParameterizedExpression:
	WithLambdaExpression | SelectorExpression | AtExpression;

ResourceExpression:
	{ResourceExpression} "ResourceExpression" "{" resourceExpr=Expression? (resourceData+=ResourceBody (","
	resourceData+=ResourceBody)*)? "}";

BinaryExpression:
	AppendExpression | OrExpression | AndExpression | NamedAccessExpression | AssignmentExpression | SelectorEntry |
	BinaryOpExpression;

ImportExpression:
	{ImportExpression} "ImportExpression" "{" (values+=IQuotedString ("," values+=IQuotedString)*)? "}";

SeparatorExpression:
	{SeparatorExpression} "SeparatorExpression" "{" "}";

StringExpression:
	SingleQuotedString | UnquotedString | DoubleQuotedString;

VariableExpression:
	{VariableExpression} "VariableExpression" "{" varName=ESTRING? "}";

LiteralExpression:
	VirtualNameOrReference | LiteralHash | LiteralName | LiteralNameOrReference | LiteralBoolean | LiteralUndef |
	LiteralDefault | LiteralRegex | LiteralClass | LiteralList;

ExpressionBlock:
	Lambda | NodeDefinition | ElseExpression | Case | PuppetManifest | UnlessExpression | IfExpression | Definition;

UnaryExpression:
	VirtualCollectQuery | UnaryMinusExpression | ExportedCollectQuery | UnaryNotExpression;

UnaryNotExpression:
	{UnaryNotExpression} "UnaryNotExpression" "{" expr=Expression? "}";

VirtualCollectQuery:
	{VirtualCollectQuery} "VirtualCollectQuery" "{" expr=Expression? "}";

UnaryMinusExpression:
	{UnaryMinusExpression} "UnaryMinusExpression" "{" expr=Expression? "}";

ExportedCollectQuery:
	{ExportedCollectQuery} "ExportedCollectQuery" "{" expr=Expression? "}";

Definition:
	HostClassDefinition;

UnlessExpression:
	{UnlessExpression} "UnlessExpression" "{" (statements+=Expression ("," statements+=Expression)*)? condExpr=Expression?
	elseStatement=Expression? "}";

IfExpression:
	ElseIfExpression;

NodeDefinition:
	{NodeDefinition} "NodeDefinition" "{" (statements+=Expression ("," statements+=Expression)*)? (hostNames+=Expression
	("," hostNames+=Expression)*)? parentName=Expression? "}";

Case:
	{Case} "Case" "{" (statements+=Expression ("," statements+=Expression)*)? (values+=Expression (","
	values+=Expression)*)? "}";

Lambda:
	RubyLambda | JavaLambda;

ElseExpression:
	{ElseExpression} "ElseExpression" "{" (statements+=Expression ("," statements+=Expression)*)? "}";

PuppetManifest:
	{PuppetManifest} "PuppetManifest" "{" (statements+=Expression ("," statements+=Expression)*)? "}";

LiteralRegex:
	{LiteralRegex} "LiteralRegex" "{" value=ESTRING? "}";

LiteralUndef:
	{LiteralUndef} "LiteralUndef" "{" "}";

LiteralDefault:
	{LiteralDefault} "LiteralDefault" "{" "}";

VirtualNameOrReference:
	{VirtualNameOrReference} "VirtualNameOrReference" "{" value=ESTRING? exported?=EBOOLEAN? "}";

LiteralList:
	{LiteralList} "LiteralList" "{" (elements+=Expression ("," elements+=Expression)*)? "}";

LiteralNameOrReference:
	{LiteralNameOrReference} "LiteralNameOrReference" "{" value=ESTRING? "}";

LiteralName:
	{LiteralName} "LiteralName" "{" value=ESTRING? "}";

LiteralBoolean:
	{LiteralBoolean} "LiteralBoolean" "{" value?=EBOOLEAN? "}";

LiteralHash:
	{LiteralHash} "LiteralHash" "{" (elements+=HashEntry ("," elements+=HashEntry)*)? "}";

LiteralClass:
	{LiteralClass} "LiteralClass" "{" "}";

DoubleQuotedString:
	{DoubleQuotedString} "DoubleQuotedString" "{" (stringPart+=TextExpression ("," stringPart+=TextExpression)*)? "}";

SingleQuotedString:
	{SingleQuotedString} "SingleQuotedString" "{" text=ESTRING? "}";

UnquotedString:
	{UnquotedString} "UnquotedString" "{" expression=Expression? "}";

IQuotedString:
	SingleQuotedString | DoubleQuotedString;

BinaryOpExpression:
	RelationshipExpression | RelationalExpression | MultiplicativeExpression | InExpression | ShiftExpression |
	EqualityExpression | AdditiveExpression | MatchingExpression;

AppendExpression:
	{AppendExpression} "AppendExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

SelectorEntry:
	{SelectorEntry} "SelectorEntry" "{" leftExpr=Expression? rightExpr=Expression? "}";

OrExpression:
	{OrExpression} "OrExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

AssignmentExpression:
	{AssignmentExpression} "AssignmentExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

NamedAccessExpression:
	{NamedAccessExpression} "NamedAccessExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

AndExpression:
	{AndExpression} "AndExpression" "{" leftExpr=Expression? rightExpr=Expression? "}";

ResourceBody:
	{ResourceBody} "ResourceBody" "{" attributes=AttributeOperations? nameExpr=Expression? "}";

WithLambdaExpression:
	MethodCall | FunctionCall;

SelectorExpression:
	{SelectorExpression} "SelectorExpression" "{" leftExpr=Expression? (parameters+=Expression (","
	parameters+=Expression)*)? "}";

AtExpression:
	{AtExpression} "AtExpression" "{" leftExpr=Expression? (parameters+=Expression ("," parameters+=Expression)*)? "}";

AttributeOperations:
	{AttributeOperations} "AttributeOperations" "{" (attributes+=AttributeOperation (","
	attributes+=AttributeOperation)*)? "}";

ICollectQuery:
	VirtualCollectQuery | ExportedCollectQuery;

RubyLambda:
	{RubyLambda} "RubyLambda" "{" (statements+=Expression ("," statements+=Expression)*)?
	arguments=DefinitionArgumentList? "}";

JavaLambda:
	{JavaLambda} "JavaLambda" "{" (statements+=Expression ("," statements+=Expression)*)?
	arguments=DefinitionArgumentList? farrow?=EBOOLEAN? "}";

ElseIfExpression:
	{ElseIfExpression} "ElseIfExpression" "{" (statements+=Expression ("," statements+=Expression)*)? condExpr=Expression?
	elseStatement=Expression? "}";

HostClassDefinition:
	{HostClassDefinition} "HostClassDefinition" "{" (statements+=Expression ("," statements+=Expression)*)?
	className=ESTRING? arguments=DefinitionArgumentList? parent=LiteralExpression? "}";

HashEntry:
	{HashEntry} "HashEntry" "{" key=Expression? value=Expression? "}";

terminal EBOOLEAN returns ecore::EBoolean:
	"true" | "false";

RelationalExpression:
	{RelationalExpression} "RelationalExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

RelationshipExpression:
	{RelationshipExpression} "RelationshipExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

AdditiveExpression:
	{AdditiveExpression} "AdditiveExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

InExpression:
	{InExpression} "InExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

ShiftExpression:
	{ShiftExpression} "ShiftExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

MultiplicativeExpression:
	{MultiplicativeExpression} "MultiplicativeExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING?
	"}";

MatchingExpression:
	{MatchingExpression} "MatchingExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

EqualityExpression:
	{EqualityExpression} "EqualityExpression" "{" leftExpr=Expression? rightExpr=Expression? opName=ESTRING? "}";

AttributeOperation:
	{AttributeOperation} "AttributeOperation" "{" value=Expression? key=ESTRING? op=ESTRING? "}";

MethodCall:
	{MethodCall} "MethodCall" "{" leftExpr=Expression? (parameters+=Expression ("," parameters+=Expression)*)?
	lambda=Lambda? parenthesized?=EBOOLEAN? methodExpr=Expression "}";

FunctionCall:
	{FunctionCall} "FunctionCall" "{" leftExpr=Expression? (parameters+=Expression ("," parameters+=Expression)*)?
	lambda=Lambda? "}";

DefinitionArgumentList:
	{DefinitionArgumentList} "DefinitionArgumentList" "{" (arguments+=DefinitionArgument (","
	arguments+=DefinitionArgument)*)? "}";

DefinitionArgument:
	{DefinitionArgument} "DefinitionArgument" "{" puppetType=Expression? argName=ESTRING? value=Expression? op=ESTRING?
	"}";

IDDT:
	EBOOLEAN | ID;

terminal ID:
	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;