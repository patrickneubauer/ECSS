/*
 * generated by Xtext 2.14.0
 */
package uk.ac.york.cs.ecss.language.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.york.cs.ecss.language.ecssLanguage.BasicTemplateRule;
import uk.ac.york.cs.ecss.language.ecssLanguage.Condition;
import uk.ac.york.cs.ecss.language.ecssLanguage.Config;
import uk.ac.york.cs.ecss.language.ecssLanguage.EcssLanguagePackage;
import uk.ac.york.cs.ecss.language.ecssLanguage.EvaluationCall;
import uk.ac.york.cs.ecss.language.ecssLanguage.ForEachExpression;
import uk.ac.york.cs.ecss.language.ecssLanguage.IfExpression;
import uk.ac.york.cs.ecss.language.ecssLanguage.Import;
import uk.ac.york.cs.ecss.language.ecssLanguage.LocalEvaluationCall;
import uk.ac.york.cs.ecss.language.ecssLanguage.LocalOrValueCall;
import uk.ac.york.cs.ecss.language.ecssLanguage.Model;
import uk.ac.york.cs.ecss.language.ecssLanguage.Property;
import uk.ac.york.cs.ecss.language.ecssLanguage.PropertyRule;
import uk.ac.york.cs.ecss.language.ecssLanguage.PropertyValue;
import uk.ac.york.cs.ecss.language.ecssLanguage.Selector;
import uk.ac.york.cs.ecss.language.ecssLanguage.SingleSelector;
import uk.ac.york.cs.ecss.language.ecssLanguage.SlotCall;
import uk.ac.york.cs.ecss.language.ecssLanguage.SlotMatch;
import uk.ac.york.cs.ecss.language.ecssLanguage.SpecificationCS;
import uk.ac.york.cs.ecss.language.ecssLanguage.StaticTemplateRulePart;
import uk.ac.york.cs.ecss.language.ecssLanguage.TemplateDef;
import uk.ac.york.cs.ecss.language.ecssLanguage.TemplateFunctionCall;
import uk.ac.york.cs.ecss.language.ecssLanguage.TemplateGenDef;
import uk.ac.york.cs.ecss.language.ecssLanguage.TemplateGeneratorRule;
import uk.ac.york.cs.ecss.language.ecssLanguage.TemplateMatch;
import uk.ac.york.cs.ecss.language.ecssLanguage.TemplateParameterValue;
import uk.ac.york.cs.ecss.language.ecssLanguage.TypeDef;
import uk.ac.york.cs.ecss.language.services.EcssLanguageGrammarAccess;

@SuppressWarnings("all")
public class EcssLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EcssLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EcssLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EcssLanguagePackage.BASIC_TEMPLATE_RULE:
				sequence_BasicTemplateRule(context, (BasicTemplateRule) semanticObject); 
				return; 
			case EcssLanguagePackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case EcssLanguagePackage.CONFIG:
				sequence_Config(context, (Config) semanticObject); 
				return; 
			case EcssLanguagePackage.EVALUATION_CALL:
				sequence_EvaluationCall(context, (EvaluationCall) semanticObject); 
				return; 
			case EcssLanguagePackage.FOR_EACH_EXPRESSION:
				sequence_ForEachExpression(context, (ForEachExpression) semanticObject); 
				return; 
			case EcssLanguagePackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case EcssLanguagePackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case EcssLanguagePackage.LOCAL_EVALUATION_CALL:
				sequence_LocalEvaluationCall(context, (LocalEvaluationCall) semanticObject); 
				return; 
			case EcssLanguagePackage.LOCAL_OR_VALUE_CALL:
				sequence_LocalOrValueCall(context, (LocalOrValueCall) semanticObject); 
				return; 
			case EcssLanguagePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case EcssLanguagePackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case EcssLanguagePackage.PROPERTY_RULE:
				sequence_PropertyRule(context, (PropertyRule) semanticObject); 
				return; 
			case EcssLanguagePackage.PROPERTY_VALUE:
				sequence_PropertyValue(context, (PropertyValue) semanticObject); 
				return; 
			case EcssLanguagePackage.SELECTOR:
				sequence_Selector(context, (Selector) semanticObject); 
				return; 
			case EcssLanguagePackage.SINGLE_SELECTOR:
				sequence_SingleSelector(context, (SingleSelector) semanticObject); 
				return; 
			case EcssLanguagePackage.SLOT_CALL:
				sequence_SlotCall(context, (SlotCall) semanticObject); 
				return; 
			case EcssLanguagePackage.SLOT_MATCH:
				sequence_SlotMatch(context, (SlotMatch) semanticObject); 
				return; 
			case EcssLanguagePackage.SPECIFICATION_CS:
				sequence_SpecificationCS(context, (SpecificationCS) semanticObject); 
				return; 
			case EcssLanguagePackage.STATIC_TEMPLATE_RULE_PART:
				sequence_StaticTemplateRulePart(context, (StaticTemplateRulePart) semanticObject); 
				return; 
			case EcssLanguagePackage.TEMPLATE_DEF:
				sequence_TemplateDef(context, (TemplateDef) semanticObject); 
				return; 
			case EcssLanguagePackage.TEMPLATE_FUNCTION_CALL:
				sequence_TemplateFunctionCall(context, (TemplateFunctionCall) semanticObject); 
				return; 
			case EcssLanguagePackage.TEMPLATE_GEN_DEF:
				sequence_TemplateGenDef(context, (TemplateGenDef) semanticObject); 
				return; 
			case EcssLanguagePackage.TEMPLATE_GENERATOR_RULE:
				sequence_TemplateGeneratorRule(context, (TemplateGeneratorRule) semanticObject); 
				return; 
			case EcssLanguagePackage.TEMPLATE_MATCH:
				sequence_TemplateMatch(context, (TemplateMatch) semanticObject); 
				return; 
			case EcssLanguagePackage.TEMPLATE_PARAMETER_VALUE:
				sequence_TemplateParameterValue(context, (TemplateParameterValue) semanticObject); 
				return; 
			case EcssLanguagePackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     TemplateRuleOrDef returns BasicTemplateRule
	 *     TemplateRule returns BasicTemplateRule
	 *     BasicTemplateRule returns BasicTemplateRule
	 *
	 * Constraint:
	 *     (type=[TemplateDef|ID] name=ID groups+=ID*)
	 */
	protected void sequence_BasicTemplateRule(ISerializationContext context, BasicTemplateRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     expression=SpecificationCS
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.CONDITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.CONDITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getExpressionSpecificationCSParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Config returns Config
	 *
	 * Constraint:
	 *     (
	 *         (hasMinImprovement?='minImprovement' minImprovement=NUMBER)? 
	 *         (hasMaxDegression?='maxDegression' maxDegression=NUMBER)? 
	 *         (haxMaxThings?='maxThings' maxThings=INT)?
	 *     )
	 */
	protected void sequence_Config(ISerializationContext context, Config semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRulePart returns EvaluationCall
	 *     EvaluationCall returns EvaluationCall
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_EvaluationCall(ISerializationContext context, EvaluationCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.EVALUATION_CALL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.EVALUATION_CALL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEvaluationCallAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRulePart returns ForEachExpression
	 *     ForEachExpression returns ForEachExpression
	 *
	 * Constraint:
	 *     (type=ID? variable=ID (exprVar=ID | completeExpr=STRING) join+=TemplateRulePart* body+=TemplateRulePart*)
	 */
	protected void sequence_ForEachExpression(ISerializationContext context, ForEachExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRulePart returns IfExpression
	 *     IfExpression returns IfExpression
	 *
	 * Constraint:
	 *     (val=ID then+=TemplateRulePart* else+=TemplateRulePart*)
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRulePart returns LocalEvaluationCall
	 *     LocalEvaluationCall returns LocalEvaluationCall
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_LocalEvaluationCall(ISerializationContext context, LocalEvaluationCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.LOCAL_EVALUATION_CALL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.LOCAL_EVALUATION_CALL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalEvaluationCallAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRulePart returns LocalOrValueCall
	 *     LocalOrValueCall returns LocalOrValueCall
	 *
	 * Constraint:
	 *     (name=ID | name=QUALIFIEDNAME)
	 */
	protected void sequence_LocalOrValueCall(ISerializationContext context, LocalOrValueCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             ((config=Config importStatement+=Import+) | importStatement+=Import+)? 
	 *             (templateDefs+=TemplateDef | templateGenDefs+=TemplateGenDef | templates+=TemplateRule | properties+=PropertyRule)+
	 *         ) | 
	 *         (templateDefs+=TemplateDef | templateGenDefs+=TemplateGenDef | templates+=TemplateRule | properties+=PropertyRule)+
	 *     )?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyRule returns PropertyRule
	 *
	 * Constraint:
	 *     (selector=Selector? property+=Property*)
	 */
	protected void sequence_PropertyRule(ISerializationContext context, PropertyRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyValue returns PropertyValue
	 *
	 * Constraint:
	 *     (
	 *         (value=ID | value=STRING | valueNumb=PossiblySignedNumber | oclvalue=SpecificationCS) 
	 *         (hasProperty?='(' (argument+=PropertyValue argument+=PropertyValue*)?)?
	 *     )
	 */
	protected void sequence_PropertyValue(ISerializationContext context, PropertyValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     ((templateMatch=TemplateMatch | slotMatch=SlotMatch | name=ID | name=STRING) condition=Condition? value+=PropertyValue+)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Selector returns Selector
	 *
	 * Constraint:
	 *     selectors+=SingleSelector+
	 */
	protected void sequence_Selector(ISerializationContext context, Selector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleSelector returns SingleSelector
	 *
	 * Constraint:
	 *     ((allTypes?='*' | referredName=ID | referredName=STRING) condition=Condition?)
	 */
	protected void sequence_SingleSelector(ISerializationContext context, SingleSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRulePart returns SlotCall
	 *     SlotCall returns SlotCall
	 *
	 * Constraint:
	 *     (name=ID (minValue=INT maxValue=INT)?)
	 */
	protected void sequence_SlotCall(ISerializationContext context, SlotCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SlotMatch returns SlotMatch
	 *
	 * Constraint:
	 *     (first=SingleSelector second=SingleSelector)
	 */
	protected void sequence_SlotMatch(ISerializationContext context, SlotMatch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.SLOT_MATCH__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.SLOT_MATCH__FIRST));
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.SLOT_MATCH__SECOND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.SLOT_MATCH__SECOND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSlotMatchAccess().getFirstSingleSelectorParserRuleCall_2_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getSlotMatchAccess().getSecondSingleSelectorParserRuleCall_4_0(), semanticObject.getSecond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpecificationCS returns SpecificationCS
	 *
	 * Constraint:
	 *     ownedExpression=STRING
	 */
	protected void sequence_SpecificationCS(ISerializationContext context, SpecificationCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.SPECIFICATION_CS__OWNED_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.SPECIFICATION_CS__OWNED_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpecificationCSAccess().getOwnedExpressionSTRINGTerminalRuleCall_0(), semanticObject.getOwnedExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRulePart returns StaticTemplateRulePart
	 *     StaticTemplateRulePart returns StaticTemplateRulePart
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StaticTemplateRulePart(ISerializationContext context, StaticTemplateRulePart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.STATIC_TEMPLATE_RULE_PART__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.STATIC_TEMPLATE_RULE_PART__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStaticTemplateRulePartAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRuleOrDef returns TemplateDef
	 *     TemplateDef returns TemplateDef
	 *
	 * Constraint:
	 *     (name=ID javaClass=QUALIFIEDNAME)
	 */
	protected void sequence_TemplateDef(ISerializationContext context, TemplateDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.TEMPLATE_RULE_OR_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.TEMPLATE_RULE_OR_DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.TEMPLATE_DEF__JAVA_CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.TEMPLATE_DEF__JAVA_CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTemplateDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTemplateDefAccess().getJavaClassQUALIFIEDNAMETerminalRuleCall_3_0(), semanticObject.getJavaClass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRulePart returns TemplateFunctionCall
	 *     TemplateFunctionCall returns TemplateFunctionCall
	 *
	 * Constraint:
	 *     (isReference?='@'? name=ID (parValue+=TemplateParameterValue parValue+=TemplateParameterValue*)?)
	 */
	protected void sequence_TemplateFunctionCall(ISerializationContext context, TemplateFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateGenDef returns TemplateGenDef
	 *
	 * Constraint:
	 *     (name=ID superRule=[TemplateRuleOrDef|ID]? javaClass=QUALIFIEDNAME?)
	 */
	protected void sequence_TemplateGenDef(ISerializationContext context, TemplateGenDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateRuleOrDef returns TemplateGeneratorRule
	 *     TemplateRule returns TemplateGeneratorRule
	 *     TemplateGeneratorRule returns TemplateGeneratorRule
	 *
	 * Constraint:
	 *     (
	 *         type=[TemplateGenDef|ID] 
	 *         name=ID 
	 *         groups+=ID* 
	 *         (typeDef+=TypeDef typeDef+=TypeDef*)? 
	 *         (idPart+=TemplateRulePart | idPart+=TemplateRulePart+)? 
	 *         templateRulePart+=TemplateRulePart*
	 *     )
	 */
	protected void sequence_TemplateGeneratorRule(ISerializationContext context, TemplateGeneratorRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateMatch returns TemplateMatch
	 *
	 * Constraint:
	 *     selector=SingleSelector
	 */
	protected void sequence_TemplateMatch(ISerializationContext context, TemplateMatch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.TEMPLATE_MATCH__SELECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.TEMPLATE_MATCH__SELECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTemplateMatchAccess().getSelectorSingleSelectorParserRuleCall_2_0(), semanticObject.getSelector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemplateParameterValue returns TemplateParameterValue
	 *
	 * Constraint:
	 *     (propName=ID | varName=ID | (slotName=ID (minValue=INT maxValue=INT)?) | direct=STRING)
	 */
	protected void sequence_TemplateParameterValue(ISerializationContext context, TemplateParameterValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDef returns TypeDef
	 *
	 * Constraint:
	 *     (type=ID name=ID)
	 */
	protected void sequence_TypeDef(ISerializationContext context, TypeDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.TYPE_DEF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.TYPE_DEF__TYPE));
			if (transientValues.isValueTransient(semanticObject, EcssLanguagePackage.Literals.TYPE_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EcssLanguagePackage.Literals.TYPE_DEF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDefAccess().getTypeIDTerminalRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getTypeDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
